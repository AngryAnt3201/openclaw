/**
 * OpenClaw tool for creating and managing Maestro apps.
 *
 * Allows the agent to scaffold new apps, generate code via Claude Code sessions,
 * start dev servers, and check app status.
 */

import { Type } from "@sinclair/typebox";
import fs from "node:fs/promises";
import path from "node:path";
import type { AnyAgentTool } from "./common.js";
import { stripAnsi, lastLineEndsWith } from "../../terminal/ansi.js";
import { jsonResult, readStringParam } from "./common.js";
import { tryCreateMaestroClient } from "./maestro-client.js";

const DEFAULT_APPS_DIR = path.join(process.env.HOME ?? "", "MaestroApps");

const MaestroAppSchema = Type.Object({
  action: Type.Union(
    [
      Type.Literal("create"),
      Type.Literal("generate"),
      Type.Literal("run"),
      Type.Literal("status"),
      Type.Literal("list"),
    ],
    { description: "The action to perform." },
  ),
  name: Type.Optional(Type.String({ description: "App name (required for 'create')." })),
  description: Type.Optional(Type.String({ description: "App description." })),
  template: Type.Optional(
    Type.String({
      description: "Tech stack template: react, nextjs, python, node, static (default: react).",
    }),
  ),
  appPath: Type.Optional(
    Type.String({
      description: "Path to existing app directory (for 'generate', 'run', 'status').",
    }),
  ),
  prompt: Type.Optional(
    Type.String({ description: "Generation prompt for Claude Code (required for 'generate')." }),
  ),
  autoPush: Type.Optional(
    Type.Boolean({ description: "Auto-push when generation finishes.", default: false }),
  ),
  runCommand: Type.Optional(
    Type.String({ description: "Custom command to start the app (for 'run')." }),
  ),
});

function sanitizeName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9_-]/g, "-")
    .replace(/--+/g, "-")
    .replace(/^-|-$/g, "")
    .toLowerCase();
}

function defaultRunCommand(template: string): string {
  switch (template) {
    case "react":
    case "nextjs":
    case "node":
      return "npm run dev";
    case "python":
      return "python -m http.server 3000";
    case "static":
      return "npx serve .";
    default:
      return "npm run dev";
  }
}

function claudeMdContent(name: string, description: string, template: string): string {
  return `# ${name}

${description}

## Tech Stack
- Template: ${template}

## Development
- This app was scaffolded by Maestro and generated by Claude Code.
- Focus on clean, production-ready code.
- Use modern best practices for the chosen stack.
`;
}

export function createMaestroAppTool(): AnyAgentTool {
  return {
    label: "Maestro Apps",
    name: "maestro_app",
    description:
      "Create and manage Maestro apps. Use this to scaffold new web apps, generate code with Claude Code, and start dev servers. Actions: create (scaffold new app), generate (start Claude Code to build it), run (start dev server), status (check session), list (list apps).",
    parameters: MaestroAppSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;
      const action = readStringParam(params, "action", { required: true });

      switch (action) {
        case "create": {
          const name = readStringParam(params, "name", { required: true });
          const description = readStringParam(params, "description") ?? "";
          const template = readStringParam(params, "template") ?? "react";
          const dirName = sanitizeName(name);
          const appPath = path.join(DEFAULT_APPS_DIR, dirName);

          try {
            // Create directory
            await fs.mkdir(appPath, { recursive: true });

            // Write CLAUDE.md
            await fs.writeFile(
              path.join(appPath, "CLAUDE.md"),
              claudeMdContent(name, description, template),
            );

            // Write .gitignore
            await fs.writeFile(
              path.join(appPath, ".gitignore"),
              "node_modules/\ndist/\n.env\n.DS_Store\n",
            );

            // Write README
            await fs.writeFile(path.join(appPath, "README.md"), `# ${name}\n\n${description}\n`);

            // Git init + initial commit
            const { execSync } = await import("node:child_process");
            execSync("git init", { cwd: appPath, stdio: "ignore" });
            execSync("git add -A", { cwd: appPath, stdio: "ignore" });
            execSync('git commit -m "Initial scaffold"', {
              cwd: appPath,
              stdio: "ignore",
              env: {
                ...process.env,
                GIT_AUTHOR_NAME: "Maestro",
                GIT_AUTHOR_EMAIL: "maestro@local",
                GIT_COMMITTER_NAME: "Maestro",
                GIT_COMMITTER_EMAIL: "maestro@local",
              },
            });

            return jsonResult({
              success: true,
              app_path: appPath,
              name,
              template,
              message: `App "${name}" scaffolded at ${appPath}. Use 'generate' to build it with Claude Code.`,
            });
          } catch (err) {
            return jsonResult({ error: `Failed to create app: ${String(err)}` });
          }
        }

        case "generate": {
          const appPath = readStringParam(params, "appPath", { required: true });
          const prompt = readStringParam(params, "prompt", { required: true });
          const autoPush = params.autoPush === true;

          const client = tryCreateMaestroClient();
          if (!client) {
            return jsonResult({
              error: "Maestro is not running. Start Maestro first.",
            });
          }

          try {
            const session = await client.createSession({
              projectPath: appPath,
              initialPrompt: prompt,
              autoPush,
            });

            return jsonResult({
              success: true,
              session_id: session.session_id,
              app_path: appPath,
              message: `Generation session ${session.session_id} started. Claude Code is building the app.`,
            });
          } catch (err) {
            return jsonResult({ error: `Failed to start generation: ${String(err)}` });
          }
        }

        case "run": {
          const appPath = readStringParam(params, "appPath", { required: true });
          const template = readStringParam(params, "template") ?? "react";
          const runCommand = readStringParam(params, "runCommand") ?? defaultRunCommand(template);

          const client = tryCreateMaestroClient();
          if (!client) {
            return jsonResult({
              error: "Maestro is not running. Start Maestro first.",
            });
          }

          try {
            // Create a plain session (no Claude, just a shell to run the dev server)
            const session = await client.createSession({
              projectPath: appPath,
              mode: "plain",
            });

            // Poll for shell readiness using end-of-line matching.
            // Checks that the last non-empty line ends with a prompt char,
            // preventing false positives from $ in MOTD, PATH vars, or OSC titles.
            // Includes a 300ms stability window: after a match, waits for output
            // to stop changing before declaring ready.
            const shellMarkers = ["$", "%", ">"];
            const pollInterval = 200;
            const maxWait = 5000;
            const stabilityMs = 300;
            let ready = false;
            let cursor = 0;
            let accumulated = "";
            let stabilityStart: number | null = null;

            for (let elapsed = 0; elapsed < maxWait; elapsed += pollInterval) {
              try {
                const resp = await client.getOutput(session.session_id, cursor);
                const gotNew = resp.cursor > cursor;
                if (gotNew) {
                  accumulated += stripAnsi(resp.output);
                  cursor = resp.cursor;
                  stabilityStart = null; // reset stability on new output
                }

                const matched = shellMarkers.some((m) => lastLineEndsWith(accumulated, m));

                if (matched) {
                  if (stabilityStart === null) {
                    stabilityStart = Date.now();
                  }
                  if (Date.now() - stabilityStart >= stabilityMs) {
                    ready = true;
                    break;
                  }
                } else {
                  stabilityStart = null;
                }
              } catch {
                // Session output not available yet — keep polling
              }
              await new Promise((resolve) => setTimeout(resolve, pollInterval));
            }
            if (!ready) {
              // Timeout — send anyway (better than silently giving up)
            }
            await client.sendInput(session.session_id, `${runCommand}\n`);

            return jsonResult({
              success: true,
              session_id: session.session_id,
              run_command: runCommand,
              message: `App dev server started in session ${session.session_id} with: ${runCommand}`,
            });
          } catch (err) {
            return jsonResult({ error: `Failed to start app: ${String(err)}` });
          }
        }

        case "status": {
          const appPath = readStringParam(params, "appPath", { required: true });

          const client = tryCreateMaestroClient();
          if (!client) {
            return jsonResult({ error: "Maestro is not running." });
          }

          try {
            const sessions = await client.listSessions();
            const appSessions = sessions.filter((s) => s.project_path === appPath);

            // Check if directory exists and has content
            let files: string[] = [];
            try {
              files = await fs.readdir(appPath);
            } catch {
              // Directory doesn't exist
            }

            return jsonResult({
              app_path: appPath,
              exists: files.length > 0,
              files: files.slice(0, 20),
              active_sessions: appSessions.map((s) => ({
                id: s.id,
                status: s.status,
                mode: s.mode,
              })),
            });
          } catch (err) {
            return jsonResult({ error: `Failed to check app status: ${String(err)}` });
          }
        }

        case "list": {
          try {
            const entries = await fs.readdir(DEFAULT_APPS_DIR).catch(() => []);
            const apps: Array<{ name: string; path: string; hasGit: boolean }> = [];

            for (const entry of entries) {
              const fullPath = path.join(DEFAULT_APPS_DIR, entry);
              const stat = await fs.stat(fullPath).catch(() => null);
              if (stat?.isDirectory()) {
                const hasGit = await fs
                  .access(path.join(fullPath, ".git"))
                  .then(() => true)
                  .catch(() => false);
                apps.push({ name: entry, path: fullPath, hasGit });
              }
            }

            return jsonResult({
              apps_dir: DEFAULT_APPS_DIR,
              count: apps.length,
              apps,
            });
          } catch (err) {
            return jsonResult({ error: `Failed to list apps: ${String(err)}` });
          }
        }

        default:
          return jsonResult({ error: `Unknown action: ${action}` });
      }
    },
  };
}
